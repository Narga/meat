#!/bin/bash

###############################################################################
# COWMAN!!!! simple fast AUR helper, using cower as a back end
###############################################################################
# falconindy: cow_install() will be rewritten, as will a lot of that stuff
#             i wanted to get a basic structure in place to work from
#             can fix shit from here
###############################################################################
# TODO: restructure flow to use cower -dd for dep resolution
#       fix the downloading/installing shit in general
#       efficiency!!!!
#       write documentation
#         make note of default overwriting of existing package dirs
#           specify that an alternate target should be used
#       all kinds of shit :(
###############################################################################

shopt -s nullglob nocasematch

### location of config file
declare config_file=$HOME/.config/cowman/config
declare git_sums_file=$HOME/.config/cowman/.gitsums
#declare errlog_file=$HOME/.config/cowman/errors.log
#declare log_file=$HOME/.config/cowman/everything.log

### default values
declare download_dir=/tmp/cowman
declare gitcheck_dir=/tmp/gitcheck.$$
declare color=no
declare -i verbosity=1
declare -i aur=1
declare -i repos=1
declare -i gitcheck=1

### default programs
declare -a pacman=(pacman)
declare -a cower=(cower)
declare -a makepkg=(makepkg)
declare -a expac=(expac)

### global variables
# color handling
declare red=$(tput bold; tput setaf 1)
declare yellow=$(tput bold; tput setaf 3)
declare reset=$(tput sgr0)

# option handling
declare -a options=()
declare -i op_declared=0
declare operation=
declare -i info_level=0
declare -i download=0
declare -i msearch=0
declare -i search=0
declare -i update=0
declare -i force=0
declare -a ignore=()
declare -a repo_ignore=()
declare -a addignore=()
declare -i check_git=0

# stacks: stuff to download
declare -a targets=()
declare -a pac_targets=()
declare -a cow_targets=()
declare -i stack_size=0
declare -a git_ignore=()

### standard functions
# print error message, exit
die() { 
  if [[ $color = yes ]]; then
    printf "$red%s:$reset" "error"
  else
    printf "$(tput bold)%s:$reset" "error"
  fi
  printf "\t %s\n" "$@" >&2
  exit 1
}

# print error message, first arg indicates level of verbosity required
warn() { 
  local v=$1; shift
  ((verbosity >= v)) || return
  if [[ $color = yes ]]; then
    printf "$yellow%s:$reset" "warning"
  else
    printf "$(tput bold)%s:$reset" "warning"
  fi
  printf " %s\n" "$1" >&2; shift
  printf "\t %s\n" "$@" >&2
}

# print info message, first arg indicates level of verbosity required
info() {
  local v=$1; shift
  ((verbosity >= v)) || return
  tput bold; printf "%s\n" "$@" >&2; tput sgr0
}

### print usage information
usage() {
  case $1 in
    D) ;;
    Q) ;;
    R) ;;
    S) ;;
    U) ;;
    *) # default help info
  cat <<EOF
usage: cowman <operation> [...]
operations:
    cowman -Syu ( full system update )
EOF
    ;;
  esac
}

### download and install through cower
# first arg is download directory, the rest is a list of packages to install
cow_install() {
  local pkg
  pushd "$1" || die "error while changing to directory '$1'"; shift
  (($#)) || return

  # remove ignored packages from download list
  for pkg; do
    inarray "$pkg" "${git_ignore[@]}" || targets+=("$pkg")
  done

  # delete existing build directories to avoid conflicts
  for pkg in "${targets[@]}"; do
    info 2 "checking for '$pkg' directory, deleting if it exists"
    [[ -d $pkg ]] && rm -rf "$pkg"
  done

  # download packages
  hide "${cower[@]}" -d "${targets[@]}" || die "cower error, possibly a timeout"

  # build and install
  for pkg; do
    pushd "$pkg" || die "error while changing to dir '$pkg'"
    "${makepkg[@]}" || die "error making package '$pkg'"
    sudo "${pacman[@]}" -U *.pkg.tar.xz
  popd; done
  popd
}
    
### download packages, parse cower output for dependency info
download() {
  local flag pkg info

  # parse cower output, add to stacks
  while read -r flag pkg info; do
    case $flag in
      S)
        cow_targets+=("$pkg")
        info 2 "$info"
        ;;
      W)
        pac_targets+=("$pkg")
        info 2 "$info"
        ;;
      *)
        die "$pkg $info"
        return 1
        ;;
    esac
  done < <("${cower[@]}" -ddb "$@")
}

### check if installed git packages are up to date
gitcheck() {
  local pkg tmp
  local newsum oldsum name sum
  # create directory to check git packages
  mkdir -p "$gitcheck_dir" && pushd "$gitcheck_dir" || \
        die "error creating gitcheck directory $gitcheck_dir"
  tmp=$(mktemp) || die "error creating temp file"
  trap "rm -rf '$gitcheck_dir' '$tmp' &>/dev/null" EXIT

  # check for updates
  for pkg; do
    # delete existing build directories to avoid conflicts
    info 2 "checking for '$pkg' directory, deleting if it exists"
    [[ -d $pkg ]] && rm -rf "$pkg"

    # source PKGBUILD, get git source
    info 2 "sourcing PKGBUILD for '$pkg'"
    if [[ ! -r $download_dir/$pkg/PKGBUILD ]]; then
      hide "${cower[@]}" -d "$pkg" || {
        warn 1 "error downloading PKGBUILD for '$pkg', skipping"
        continue
      }
    fi
    . "$download_dir/$pkg/PKGBUILD" || {
      warn 1 "error sourcing PKGBUILD for '$pkg', skipping"
      continue
    }
      
    # clone into git
    info 2 "cloning git repo for '$pkg'"
    hide git clone "$_gitroot" "$_gitname" || {
      warn 1 "$_gitname not found in github, check '$_gitroot', skipping"
      continue
    }

    # get current md5sum
    if pushd "$_gitname"; then
      newsum=$(git rev-parse origin) || {
        warn 1 "error getting md5sum for '$pkg', skipping"
        continue
      }
      popd; rm -rf "$_gitname"
    else
      warn 1 "error changing dir for '$pkg', skipping"
      continue
    fi

    # get old md5sum from file
    oldsum=$(awk -v name="$_gitname" '$1 == name {print $2}' "$git_sums_file")

    # compare sums
    if [[ $oldsum = "$newsum" ]]; then
      info 1 "'$pkg' is up to date"
      continue
    fi

    # this stuff is only done if the md5sums don't match
    info 1 "'$pkg' is out of date, adding to queue" && {
      awk -v name="$_gitname" '$1 != name' "$git_sums_file"
      printf "%s %s\n" "$_gitname" "$newsum"
    } >"$tmp" && mv "$tmp" "$git_sums_file"
    push "$pkg"
  done
  popd
}

### run command, suppressing output according to verbosity
hide() {
  if ((verbosity >= 2)); then
    "$@"
  else
    "$@" &>/dev/null
  fi
}

### checks if value is in an array
# usage: inarray "$value" "${array[@]}"
inarray() {
  local val=$1 cur; shift
  for cur; do
    [[ $val = "$cur" ]] && return
  done
}

### run command as root
runasroot() {
  if ((UID == 0)); then
    "$@"
  elif sudo -v &>/dev/null && sudo -l "$@" &>/dev/null; then
    sudo "$@"
  else
    printf "%s " "root"
    su root -c "$(printf '%q' "$@")"
  fi
}

### stack handling functions
# add value to pacman list
# usage pacadd 'value'
pacadd() {
  pac_targets+=("$@")
}

# pop value from top of stack
# usage: value=$(pop)
pop() {
  printf "%s" "${cow_targets[--stack_size]}"
}

# push value to top of stack
# usage: push 'value'
push() {
  cow_targets[stack_size++]=("$1")
}

### parse options list, turn combined arguments into single arguments
parse_opts() {
  while (($#)); do
    if [[ $1 = -[!-]* ]]; then
      for ((i=1; i<${#1}; i++)); do
        options+=("-${1:i:1}")
      done
    elif [[ $1 = --*=* ]]; then
      options+=("${1%%=*}" "${1#*=}")
    else
      options+=("$1")
    fi
    shift
  done
}

### full system upgrade
upgrade() {
  ((repos)) && sudo "${pacman[@]}" -Syu
  ((aur)) && cow_install "$download_dir" $(cower -uq)
}

### main body of the program
# start logging
#if mkdir -p "${log_file%/*}" "${errlog_file%/*}"; then
#  if touch "$log_file" "$errlog_file"; then
#    exec 2> >(tee "$errlog_file" "$log_file") > >(tee "$log_file")
#  else
#    warn 1 "log file directories created successfully, but an error occured while creating the log files"
#  fi
#else
#  warn 1 "error creating log file directories"
#fi

# get configuration options
if [[ -r $config_file ]]; then
  . "$config_file"
else
  warn 1 "error sourcing config file $config_file" \
         "reverting to default values"
fi

# parse options
parse_opts "$@" && set -- "${options[@]}"
while [[ $1 = -* ]]; do
  case "$1" in
    # operations
    -h|--help|-\?) 
      usage
      exit
      ;;
    -d|--download) 
      ((op_declared++))
      download=1
      shift
      ;;
    -i|--info)
      ((! info_level && op_declared++))
      ((info_level++))
      shift
      ;;
    -m|--msearch)
      ((op_declared++))
      msearch=1
      shift
      ;;
    -s|--search)
      ((op_declared++))
      search=1
      shift
      ;;
    -u|--update)
      ((op_declared++))
      update=1
      shift
      ;;

    # options
    -c|--color)
      color=yes
      shift
      ;;
    -v|--verbose|--debug)
      if [[ $1 = --debug ]]; then
        verbosity=3
      else
        ((verbosity++))
      fi
      shift
      ;;
    -f|--force)
      force=1
      shift
      ;;
    --format*)
      cower+=(--format="$2")
      shift 2
      ;;
    --ignore*)
      [[ $2 = *\ * ]] && { usage; die "invalid ignore list format: $2"; }
      [[ $2 = -* ]] && { usage; die "no --ignore targets specified"; }
      IFS=, read -ra addignore <<<"$2"
      ignore+=("${addignore[@]}")
      shift 2
      unset addignore
      ;;
    --ignorerepo*)
      [[ $2 = *\ * ]] && { usage; die "invalid repo ignore list format: $2"; }
      [[ $2 = -* ]] && { usage; die "no --ignorerepo targets specified"; }
      IFS=, read -ra addignore <<<"$2"
      repo_ignore+=("${addignore[@]}")
      shift 2
      unset addignore
      ;;
    --nossl)
      cower+=(--nossl)
      shift
      ;;
    -t|--target)
      [[ $2 = -* ]] && { usage; die "no download targets specified"; }
      download_dir=$2
      shift 2
      ;;
    --threads)
      [[ $2 = -* ]] && { usage; die "must specify number of threads"; }
      [[ $2 = *[![:digit:]]* ]] && { 
        usage
        die "invalid number of threads: $2"
      } 
      cower+=(--threads=$2)
      shift 2
      ;;
    -g|--git-check)
      check_git=1
      shift
      ;;

    # check for invalid options
    -*)
      usage
      die 'invalid option: $1'
      ;;
  esac
done

# option error handling, format checking
if ((op_declared > 1)); then
  die 'only one operation may be specified'
elif ((! op_declared)); then
  die 'no operation specified'
fi
for param; do
  if [[ $param = -* ]]; then
    die "$param: invalid package name" \
        "all operations and options must be specified before packages"
  fi
done

if ((download)); then
  operation=download
elif ((info_level)); then
  operation=info
elif ((msearch)); then
  operation=msearch
elif ((search)); then
  operation=search
elif ((update)); then
  operation=update
else
  die "ZOMG WTF shit blew up" "error setting operation, this should never be seen"
fi

# color info
if [[ $color = yes ]]; then
  if type -P pacman-color &>/dev/null; then
    pacman=(pacman-color) 
  else
    warn 1 'pacman-color is not installed' \
           'please install pacman-color for color support' \
           'defaulting to normal output'
  fi
  cower+=(-c) 
else
  makepkg+=(-m)
fi

# build cower and pacman base commands from options
if ((verbosity >= 3)); then
  pacman+=(--debug)
  cower+=(-v)
  expac+=(-v)
fi
pacman+=(--noconfirm)
cower+=(-t "$download_dir")
if [[ ${ignore[*]} ]]; then
  oIFS=$IFS; IFS=,; cower+=(--ignore=${ignore[*]}); IFS=$oIFS
fi
if [[ ${repo_ignore[*]} ]]; then
  oIFS=$IFS; IFS=,; cower+=(--ignorerepo=${repo_ignore[*]}); IFS=$oIFS
fi

# make sure download dir exists
mkdir -p "$download_dir" || die "download dir $download_dir can't be created" \
                                "check permissions"

# finally, we get to do shit!!!
case $operation in
  download)
    ;;
  info)
    if ((info_level == 1)); then
      "${cower[@]}" -i "$@"
    else
      "${cower[@]}" -ii "$@"
    fi
    ;;
  msearch)
    "${cower[@]}" -m "$@"
    ;;
  search)
    "${cower[@]}" -s "$@"
    ;;
  update)
    upgrade
    ;;
esac

# vim set ts=2 sw=2 #
